软件 = 数据结构+算法+软件环境
数据结构 = 数据 + 结构 + 算子（运算、函数）
逻辑结构：存在于思想当中，是看不见和摸不着的；分为线性逻辑结构与非线性逻辑结构；
物理结构：内存存储的真实结构；分为物理线性结构（数组）和物理非线性结构（链表）
线性结构：线性表、堆栈、队列、数组、矩阵、串；
非线性结构：链表、树、二叉树、图
衡量算法优劣性方法：时间复杂度+空间复杂度；
时间复杂度：是问题规模与完成该问题所需要的基础操作步骤数量的函数关系

#define NOT_FOUND -1

int findKey(int *array,int count,int key){
   int index = 0;
   
   while(index < count && array[index] != key){
       index ++;
   }
   
   return index >= count ? NOT_FOUND : index;
}

上面这个例子查找算法的基础操作是array[index] != key;
1 + 2 + 3 + ... + n = (1+n)/2
总查找次数：n
那么，每一次查找所比较的次数是：((1+n) * n/2)/n = (1+n)/2;

n表示数据规模，那么这个查询算法的时间复杂度是O((1+n)/2);当n趋于无穷大时，那么n趋于无穷大时，那么：O((1+n)/2 <==> O(n))，等价关系，即该查找算法时间复杂度O(n)。

空间复杂度：任务规模与实现该任务所需要的辅助存储空间大小之间的函数。
==================================================================
1、数组
所申请的内存空间，必须是线性连续，且申请的空间大小必须提前确定
插入和删除操作代价比较大，需要该位置后面的数据都向后移动，留出一个空位进行插入，或者都向前移动，把该空位的数据进行覆盖（也就是删除）；
查询代价较小，数组时连续存储的，知道这个数组的名称，可根据下标直接查询；
不利于扩展，数组空间都是提前申请的，当存储空间不够时，需要重新申请空间。
2、链表
申请内存中存储空间，不要求连续，只需要保存下一个存储空间的内存地址即可。
插入和删除操作比较容易，只需要改变指针的指向即可；查询代价较大，不具备随机访问能力，需要从头到尾遍历查找。
扩展性较好，不用提前指定大小，插入删除比较随意。
3、时间复杂度
数组：查询O(1)、插入O(n)、删除O(n)
链表：查询O(n)、插入O(1)、删除O(1)

内存空间利用率：每一个数组单元是100%存储数据，每一个链表单元是存储数据+存储指针，数组对于内存的利用上大于链表（当然了，还需要看是否提前知道要存储数据的个数）
==================================================================
链表所分配的空间在内存上不一定连续，但是链表具有其天然的优势。
链表主要分为4种情况：单链表，单循环链表，双链表，双循环链表，一定要反复琢磨，理解清楚我下面所画的模型：

